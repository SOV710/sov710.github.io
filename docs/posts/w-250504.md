---
title: 25 May 4th 周总结
date: 2025-05-04
category:
  - 周结
tag:
  - 全栈开发
  - REST
  - JWT
  - 前端
  - 后端
  - 中间件
  - 架构设计
  - cursor
  - neovim
cover: '/posts/w-250504-cover.png'
---
# 25 May 4th 周总结

约莫有一个月没更新周结/日结了，一直在赶一个全栈项目的代码，被ddl驱赶逼得时间管理完全崩塌，作息混乱，晕头转向，感觉糟透了，吃了这么多业务史这辈子不想再吃第二次。

说是项目，其实就是接的一个单子，但是业务性非常强，没有什么特别精巧或者复杂的处理技术，大多数只是数据流转和调库，虽然现在回头来看实现上并不麻烦，但是无奈我是完全零基础，像无头苍蝇一样乱转了好久才找到了方向。

![](/posts/w-250504-1.jpg)

唯一能称得上是收获的就是对业务代码的理解也更深了，对前后端岗写业务代码也算是怯魅了。说实话我完全想象不到自己做业务岗的样子，完全是计算机技工，几乎没有技术含量。可能大厂的前后端岗和我说的不一样吧，毕竟周围有些大佬即使技术很强（至少个人印象里确实如此）也没能进大厂的前端岗，非常令人惋惜，不过以我浅薄的理解，确实是这样的。

## 业务代码的思考

首先在谈论业务代码之前，我们需要对业务代码下一个定义：什么是业务代码？

业务代码：解决业务问题的代码，业务就是一个功能，比如说鉴权、支付、即时通讯、搜索之类。

业务问题：

- 高级一点的就是技术选型（也就是架构决策），涉及轮子或工具的选择。
- 中级一点的就是对各种轮子进行优化，深入到轮子的细节里做优化或定制化，这也不完全是业务了，像是算法那种，或者像大多数人说的狭义的"技术"
- 低级的就是关注各种轮子之间的数据流转，进行数据处理，分支判断，同时关注死锁、并发这样后端常见的问题，再做好冗余处理之类的

很多人觉得业务代码没技术含量，其实倒不是因为它简单到谁都能写才而成为了啥人都能来踢一脚的CRUD，而是因为这些问题已经被人重复思考过太多遍了，到处都是成熟的轮子。CRUD boy只需要关心轮子接口的调用和简单的数据序列化，不用处理太复杂的数据流转，只用传参传参传参传参，所以低级的业务代码本质上是强IO的。

虽然业务逻辑大部分是重复的，但是很多不能抽象成轮子，为什么？

- 需要涉及关键数据，比如库存
- 定制化需求，可能要频繁混动
- 读新轮子接口，做轮子选型的时间不如自己写一个（感觉少）
- 轮子要钱
- 老板是傻逼

然后我发现，我就算是即使全用轮子，也要写几万行代码，因为还有业务逻辑的复杂度确实依托史和胶水代码（其实就是数据流转）确实太多了。然后项目内部越是解耦，边界验参就越多，测试和运维的自动化也带来了大量的配置代码，前端的样板代码本身也相当可观，最后就真的变成了依托大份。

所以什么是强IO的代码呢？就是这样的低级业务代码，就是数据流转（业务逻辑和验参）和对轮子的配置、调用构成了绝大部分的工作量。

那么轮子和业务代码究竟有什么区别？纯技术上，我认为它们的区别更像是一种从底层到顶层的分工关系。轮子也要调用更底层的轮子，轮子和业务就是一个社会分工的上下游关系；但轮子的内部通常耦合度更高，内部数据流转远没有业务代码那么复杂。所以摆脱了高IO后就可以专注于更深的数据处理（比如说算法对吧），本质上是因为轮子是解决一个技术问题的，技术问题是不会有太多变动的；但是业务代码是产出产品的，大多数产品解决的是功能需求，而功能需求是千变万化的。所以轮子，和其他的工程代码大概没有业务代码那么大的负担。

那么轮子和业务代码究竟有什么区别？纯技术上，我认为它们的区别更像是一种从底层到顶层的分工关系。轮子也要调用更底层的轮子，轮子和业务就是一个社会分工的上下游关系；但轮子要解决的是更特定且稳定的技术问题，所以轮子的内部结构通常是很稳定的，可以做到很高的耦合度，不需要做强IO，使它摆脱了高IO负担；但是业务代码要处理非常繁杂的数据流转，面对多种场景，所以不得不高IO。说到底根本原因是轮子解决的是技术问题，业务解决的是产品问题，后者的负担明显更重，然后就变成了依托史。

所以，从IO到Process，从低级业务到算法，这之间存在着一条清晰的界线。所有工程代码的定位都在这条线上浮动，这大概就是我想表达的意思吧。

## 时间管理的悲剧

所以，为什么我浪费了这么多时间？

两个月前我第一次摸到这个项目时，我完全没有前后端的概念，我没学过软件工程，没学过web开发，没接触过任何后端框架，没学过数据库，更别提什么REST，JWT，中间件了。我实验室leader忽悠我说这项目两三天就能做完，最sb的是我当时就信了，后来我才知道他说的"两三天就能做完"是用cursor做vibe coding（mlgbd）。我因为事先没做过技术选型，让GPT帮我做技术选型但给自己的定位又不清晰，一上来就上强度，跳过前端三件套学各种框架和封装好的库，理想是应有尽有，结果是一无所有，到现在浪费了非常非常多时间。到现在这个项目我已经重构了接近十次甚至九次（悲），主要问题出在技术架构和需求上。学前端有很多种方式，学后端有很多种方式，可是我偏偏用了最耗时的那一种……


而且，我写了两个月的业务代码实际上也没有解决任何业务问题，就是写了一堆一次性的代码，没有持续性价值，没有任何的进步，可能唯一的好处的是理解了一些项目架构的逻辑，并且让自己对互联网程序员怯魅了（悲）。


另外，写完业务代码感觉到自己整个人变麻木了。写业务代码之前是很有激情的，对于任何事情都想尝试一下，我还想写hypervisor，neovim插件，学各种算法等等，但是写业务代码的时候，虽然也有很多想尝试的东西，但是自己的项目没有上下班的机制管理时间，脑子里总是在想"做完这个项目就好了"，导致我这些天全都投在补充业务逻辑上，社交、比赛、作业全部搁置。而且即使是全部投在项目上也做不完，又多了种"山就在那里"的绝望感，无论你怎么拼命干，业务逻辑就是纯体力活，就是那座大山，不是灵光一现能干完的；每天起床的时候都在想"这24个小时绝对要做完"，而每天睡觉时都在失望。有多少次想"做完这个项目就好了"就有多少次碰壁，有多少次幻想"明天开始学算法"就有多少次失落，一次又一次幻想破灭，到最后完全麻木了，现在也没完全缓过来。

而且，到后面意识到简单地堆砌时间并不能增加效率，我感觉越往后做效率显著下降，但是在ddl的逼迫下又不得不把所有时间allin业务，现在我最需要的事情是把作息调整过来，我已经一周在实验室睡觉了，感受非常糟。我完全想象不出我未来工作天天写业务代码的情况，那简直就是地狱。


![](/posts/w-250504-2.gif)

## 总结

总而言之，人生中的两个月被浪费了，尤其是最后的两天为了赶工作我从neovim切换到了cursor，亲眼看着cursor用两天写了我一个月的代码量，理解当时leader为什么让我用cursor了，不过他当时的意思应该是让我做架构而不是vibe coding……不可否认的是cursor确实改变了前后端的编程方式，简单的需求完全可以"像老板一样编程"，但是我还是不想离开neovim……这几天我要么找一个neovim下让我满意的agent插件，要么想办法写个插件，从cursor后端抓包同步到neovim里，总之现在这个时代不用agent确实对效率影响太大了。

接下来就要准备期末了，我的一学期就这么被业务毁了，扼腕。暑假再战吧。

PS：前一篇文章虽然标题是"再见前端"，事实上是到最后也没能跟前端说再见，搓组件和css太sb了，要搓吐了（
