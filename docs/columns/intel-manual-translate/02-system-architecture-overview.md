---
title: Intel® Manual Chapter 2 | Intel手册第二章中文翻译：系统架构概览
category: Intel手册中文翻译
tag:
  - x86
  - Intel
order: 2
---

自 Intel386 处理器系列开始，IA-32 架构为操作系统和系统开发软件提供了广泛的支持。这些支持包括多种运行模式，主要包括：

* 实模式（real mode）、保护模式（protected mode）、虚拟 8086 模式（virtual 8086 mode）以及系统管理模式（system management mode）。这些模式有时被称为传统模式（legacy modes）。

Intel 64 架构几乎支持 IA-32 架构下的所有系统编程功能，并在此基础上扩展出一种新的运行模式（IA-32e 模式），以支持 64 位编程环境。IA-32e 模式允许软件在两种子模式下运行：

* 64 位模式（64-bit mode）：支持 64 位操作系统和 64 位应用程序
* 兼容模式（compatibility mode）：允许大多数传统软件运行，并可与 64 位应用程序在 64 位操作系统下共存。

IA-32 的系统级架构包含如下特性，用于支持以下操作：

* 内存管理
* 软件模块的保护
* 多任务处理
* 异常与中断处理
* 多处理器支持
* 缓存管理
* 硬件资源与电源管理
* 调试与性能监控

本章将对该架构的各个部分进行说明，同时介绍用于系统级配置和控制处理器的系统寄存器，并简要概述处理器的系统级（操作系统级）指令。

系统级架构的许多特性仅供系统程序员使用。然而，应用程序开发者在为应用程序创建可靠且安全的运行环境时，也需要阅读本章及后续章节。

本节概述以及本手册的多数后续章节，主要聚焦于 IA-32 架构的保护模式操作。同时也对 Intel 64 架构中 IA-32e 模式的操作进行了说明，重点在其与保护模式的差异。

所有 Intel 64 和 IA-32 处理器在上电或复位后都会进入实地址模式（详见第 11 章“处理器管理与初始化”）。之后，软件会发起从实地址模式切换到保护模式的过程。如果需要启用 IA-32e 模式，软件还需要从保护模式切换至 IA-32e 模式。

## 2.1 系统级架构概述

系统级架构由一组寄存器、数据结构和指令组成，用于支持基本的系统级操作，如内存管理、中断与异常处理、任务管理以及多处理器控制等。

图 2-1 总结了适用于 32 位模式的系统寄存器和数据结构。适用于 IA-32e 模式的系统寄存器和数据结构则展示于图 2-2。

![Figure 2-1. IA-32 系统级寄存器与数据结构](https://pica.zhimg.com/80/v2-a477b9ddba436f8eb941a1af0299dbd6_720w.webp)

![Figure 2-2. IA-32e 模式与四级分页下的系统级寄存器与数据结构](https://picx.zhimg.com/80/v2-f4d036eb1cf80794a31e3da0d9bf0aaf_720w.webp)

### 2.1.1 全局描述符表和局部描述符表

在保护模式下，如图 2-1 所示，所有的内存访问都必须经过全局描述符表（GDT）或可选的局部描述符表（LDT）。这些表包含名为段描述符（segment descriptors）的条目。段描述符提供了段的基址、访问权限、类型以及使用信息。

每个段描述符都有一个相关联的段选择子（segment selector）。段选择子为使用它的软件提供了一个指向 GDT 或 LDT 的索引（即其关联段描述符的偏移量）、一个全局/局部标志（用于判断该选择子指向 GDT 还是 LDT）以及访问权限信息。

要访问段内的一个字节，必须提供段选择子和偏移量。段选择子用于访问该段的段描述符（在 GDT 或 LDT 中）。处理器从段描述符中获取该段在线性地址空间中的基址，然后通过偏移量确定相对于基址的字节位置。只要该段对于当前处理器所运行的当前特权级（CPL, Current Privilege Level）是可访问的，这一机制就可以用于访问任何有效的代码段、数据段或堆栈段。CPL 被定义为当前正在执行的代码段的保护级别。

参见图 2-1。图中实线箭头表示线性地址，虚线表示段选择子，点状箭头表示物理地址。为简化表示，许多段选择子在图中被画成直接指向段，实际上，段选择子到其关联段的实际路径始终是通过 GDT 或 LDT 实现的。

GDT 基址的线性地址保存在 GDT 寄存器（GDTR）中；LDT 基址的线性地址保存在 LDT 寄存器（LDTR）中。

#### 2.1.1.1 IA-32e 模式下的全局描述符表和局部描述符表

在 IA-32e 模式的两个子模式（64 位模式和兼容模式）下，GDTR 和 LDTR 寄存器都扩展为 64 位宽。详细信息参见第 3.5.2 节“IA-32e 模式下的段描述符表”。

在 64 位模式下，全局和局部描述符表也被扩展以支持 64 位基址（16 字节的 LDT 描述符可保存一个 64 位基址及其他属性）。在兼容模式下，描述符不会被扩展。

### 2.1.2 系统段、段描述符与门

除了组成程序或过程执行环境的代码段、数据段和堆栈段之外，体系结构还定义了两个系统段：任务状态段（TSS，Task-State Segment）和局部描述符表（LDT，Local Descriptor Table）。GDT 并不被视为段，因为它不是通过段选择子和段描述符进行访问的。TSS 和 LDT 都有相应的段描述符。

体系结构还定义了一组特殊描述符，称为门（gate），包括调用门（call gate）、中断门（interrupt gate）、陷阱门（trap gate）和任务门（task gate）。这些门为系统过程和处理程序提供受保护的入口，这些过程和处理程序可能运行在与应用程序和大多数普通过程不同的特权级上。例如，对调用门的 CALL 操作可以访问与当前代码段特权级相同或更低（权限更高）的代码段中的过程。通过调用门访问过程时，调用过程需提供调用门的选择子。处理器随后对调用门进行访问权限检查，比较当前特权级（CPL）与调用门及其目标代码段的特权级。

如果允许访问目标代码段，处理器将从调用门获取目标代码段的段选择子及其段内偏移量。如果调用涉及特权级切换，处理器还会切换到目标特权级的堆栈。新堆栈的段选择子由当前任务的 TSS 提供。门还便于 16 位与 32 位代码段之间的切换，反之亦然。

#### 2.1.2.1 IA-32e 模式下的门

在 IA-32e 模式下，以下描述符均为 16 字节（扩展以支持 64 位基址）：LDT 描述符、64 位 TSS、调用门、中断门和陷阱门。

调用门用于在 64 位模式与兼容模式之间进行切换。IA-32e 模式下不支持任务门。发生特权级切换时，堆栈段选择子不会从 TSS 读取，而是被设为 NULL。

---

### 2.1.3 任务状态段与任务门

任务状态段（TSS，见图 2-1）定义了某个任务的执行环境状态。TSS 包括通用寄存器、段寄存器、EFLAGS 寄存器、EIP 寄存器以及用于三个堆栈段的段选择子和堆栈指针（每个特权级一个堆栈）。TSS 还包含与任务相关联的 LDT 的段选择子以及分页结构层级的基址。

在保护模式下，所有程序执行都发生在某个任务（称为当前任务）的上下文中。当前任务的 TSS 的段选择子保存在任务寄存器（task register）中。切换到新任务的最简单方法是对新任务执行 CALL 或 JMP 指令。在此过程中，CALL 或 JMP 指令中提供新任务的 TSS 的段选择子。任务切换时，处理器会执行以下操作：

1. 将当前任务的状态保存到当前 TSS；
2. 用新任务的段选择子加载任务寄存器；
3. 通过 GDT 中的段描述符访问新 TSS；
4. 将新任务的状态从新 TSS 加载到通用寄存器、段寄存器、LDTR、控制寄存器 CR3（分页结构层级的基址）、EFLAGS 寄存器和 EIP 寄存器中；
5. 开始执行新任务。

任务还可以通过任务门访问。任务门类似于调用门，只是它通过段选择子访问 TSS，而不是代码段。

#### 2.1.3.1 IA-32e 模式下的任务状态段

IA-32e 模式下不支持硬件任务切换，但 TSS 仍然存在。TSS 的基址由其描述符指定。

64 位 TSS 包含以下对 64 位操作至关重要的信息：

* 每个特权级的堆栈指针地址；
* 中断堆栈表（interrupt stack table）的指针地址；
* IO 权限位图的偏移地址（相对于 TSS 基址）。

在 IA-32e 模式下，任务寄存器也扩展为支持 64 位基址。详见第 9.7 节“64 位模式下的任务管理”。

### 2.1.4 中断与异常处理

外部中断、软件中断和异常通过中断描述符表（IDT，Interrupt Descriptor Table）进行处理。IDT 存储了一组门描述符，这些描述符用于访问中断和异常处理程序。与 GDT 类似，IDT 并不是一个段。IDT 的基址线性地址保存在 IDT 寄存器（IDTR）中。

IDT 中的门描述符可以是中断门（interrupt gate）、陷阱门（trap gate）或任务门（task gate）描述符。要访问中断或异常处理程序，处理器首先从内部硬件、外部中断控制器或通过 INT n、INTO、INT3、INT1 或 BOUND 指令从软件接收一个中断向量。该中断向量提供了 IDT 的索引。如果选中的门描述符是中断门或陷阱门，相关处理程序的访问方式类似于通过调用门调用过程。如果描述符是任务门，则通过任务切换访问处理程序。

#### 2.1.4.1 IA-32e 模式下的中断与异常处理

在 IA-32e 模式下，中断门描述符扩展为 16 字节，以支持 64 位基址。这适用于 64 位模式和兼容模式。

IDTR 寄存器扩展为可保存 64 位基址。IA-32e 模式下不支持任务门。

---

### 2.1.5 内存管理

系统架构支持直接物理寻址或虚拟内存（通过分页）。当使用物理寻址时，线性地址即被视为物理地址。当使用分页机制时，所有代码、数据、堆栈和系统段（包括 GDT 和 IDT）都可以分页，只有最近访问的页面才会保留在物理内存中。

页面（有时称为页框，page frame）在物理内存中的位置由分页结构保存。这些结构驻留在物理内存中（32 位分页结构见图 2-1）。

分页结构层级的基址物理地址保存在控制寄存器 CR3 中。分页结构中的条目决定了页框基址的物理地址、访问权限和内存管理信息。

使用分页机制时，线性地址被分为若干部分。这些部分分别作为分页结构和页框的偏移量。系统可以拥有单一的分页结构层级，也可以有多个层级，例如每个任务拥有自己的层级。

#### 2.1.5.1 IA-32e 模式下的内存管理

在 IA-32e 模式下，物理内存页面由一组系统数据结构进行管理。在兼容模式和 64 位模式下，使用四级或五级系统数据结构（详见第 5 章“分页”）。这些结构包括：

* 第 5 级页映射表（PML5, Page Map Level 5）：PML5 表中的条目包含 PML4 表的基址物理地址、访问权限和内存管理信息。PML5 表的基址物理地址保存在 CR3 中。PML5 表仅在五级分页中使用。
* 第 4 级页映射表（PML4, Page Map Level 4）：PML4 表中的条目包含页目录指针表的基址物理地址、访问权限和内存管理信息。四级分页下，仅有一个 PML4 表，其基址物理地址存于 CR3。
* 一组页目录指针表：页目录指针表中的条目包含页目录表的基址物理地址、访问权限和内存管理信息。
* 一组页目录表：页目录表中的条目包含页表的基址物理地址、访问权限和内存管理信息。
* 一组页表：页表中的条目包含页框的物理地址、访问权限和内存管理信息。

### 2.1.6 系统寄存器

为便于处理器的初始化和系统操作控制，系统架构在 EFLAGS 寄存器中提供了系统标志位，并定义了若干系统寄存器：

* EFLAGS 寄存器中的系统标志位和 IOPL 字段用于控制任务与模式切换、中断处理、指令跟踪及访问权限。详见第 2.3 节“EFLAGS 寄存器中的系统标志与字段”。
* 控制寄存器（CR0、CR2、CR3 和 CR4）包含用于控制系统级操作的多种标志和数据字段。这些寄存器中的其他标志用于指示操作系统或管理程序对特定处理器功能的支持。详见第 2 章“控制寄存器”及第 2.6 节“扩展控制寄存器（包括 XCR0）”。
* 调试寄存器（未在图 2-1 中显示）用于设置断点，辅助程序和系统软件的调试。详见第 19 章“调试、分支分析、TSC 与 Intel® 资源监控技术（Intel® RDT）特性”。
* GDTR、LDTR 和 IDTR 寄存器包含各自表的线性地址及大小（界限）。详见第 2.4 节“内存管理寄存器”。
* 任务寄存器包含当前任务的 TSS 的线性地址和大小。详见第 2.4 节“内存管理寄存器”。
* 型号专用寄存器（MSRs，未在图 2-1 中显示）。

型号专用寄存器（MSRs, Model-Specific Registers）主要供操作系统或管理程序（即运行在特权级 0 的代码）使用。这些寄存器用于控制如调试扩展、性能监控计数器、机器检查架构（MCA）及内存类型范围（MTRRs）等。不同的 Intel 64 与 IA-32 处理器系列，其型号专用寄存器的数量和功能有所不同。详见第 11.4 节“型号专用寄存器（MSRs）”及《英特尔® 64 与 IA-32 架构软件开发手册》第 4 卷中的相关章节。

大多数系统会限制应用程序对系统寄存器（除 EFLAGS 寄存器外）的访问。但也可以设计为所有程序和过程均在最高特权级（特权级 0）运行，在这种情况下，应用程序可修改系统寄存器。

#### 2.1.6.1 IA-32e 模式下的系统寄存器

在 IA-32e 模式下，四个系统描述符表寄存器（GDTR、IDTR、LDTR 和 TR）在硬件上扩展为可保存 64 位基址。EFLAGS 寄存器变为 64 位的 RFLAGS 寄存器。CR0–CR4 扩展为 64 位，CR8 也可用。CR8 提供对任务优先级寄存器（TPR, Task Priority Register）的读写访问，使操作系统能够控制外部中断的优先级类别。

在 64 位模式下，调试寄存器 DR0–DR7 为 64 位。在兼容模式下，DR0–DR3 的地址匹配也以 64 位粒度完成。

支持 IA-32e 模式的系统中，提供扩展特性使能寄存器（IA32\_EFER, Extended Feature Enable Register），该型号专用寄存器用于控制 IA-32e 模式的激活及相关操作。此外，还有多个型号专用寄存器用于管理 IA-32e 模式下的指令：

* IA32\_KERNEL\_GS\_BASE —— 由 SWAPGS 指令使用
* IA32\_LSTAR —— 由 SYSCALL 指令使用
* IA32\_FMASK —— 由 SYSCALL 指令使用
* IA32\_STAR —— 由 SYSCALL 和 SYSRET 指令使用

### 2.1.7 其他系统资源

除前述系统寄存器和数据结构外，系统架构还提供以下附加资源：

* 操作系统指令（详见第 2.8 节“系统指令概要”）
* 性能监控计数器（未在图 2-1 中显示）
* 内部缓存和缓冲区（未在图 2-1 中显示）

性能监控计数器是一类事件计数器，可编程用于统计处理器事件，例如已解码指令数、接收到的中断数或缓存加载次数。

处理器提供若干内部缓存和缓冲区。缓存用于存储数据和指令，缓冲区用于存储已解码的系统和应用段地址以及待执行的写操作。详见第 13 章“内存缓存控制”。

## 2.2 运行模式

IA-32 架构支持三种操作模式和一种准操作模式：

* **保护模式（Protected mode）** —— 这是处理器的本地操作模式，提供丰富的体系结构特性、灵活性、高性能，并能向现有软件基础提供向后兼容性。
* **实地址模式（Real-address mode）** —— 该模式为程序员提供了与 Intel 8086 处理器相同的编程环境，并进行了少量扩展（如支持切换到保护模式或系统管理模式）。
* **系统管理模式（System Management Mode, SMM）** —— SMM 是所有 IA-32 处理器（自 Intel386 SL 处理器开始）的标准体系结构特性。该模式为操作系统或管理程序实现电源管理及 OEM 差异化功能提供了一种透明机制。SMM 通过激活外部系统中断引脚（SMI#）进入，该引脚会生成系统管理中断（SMI）。在 SMM 中，处理器切换到独立的地址空间，并保存当前运行程序或任务的上下文，随后可透明地执行 SMM 专用代码。SMM 退出后，处理器会恢复到 SMI 发生前的状态。
* **虚拟 8086 模式（Virtual-8086 mode）** —— 在保护模式下，处理器支持一种称为虚拟 8086 模式的准操作模式。该模式允许处理器在受保护、多任务环境下执行 8086 软件。

Intel 64 架构支持 IA-32 架构的所有操作模式以及 IA-32e 模式：

* **IA-32e 模式（IA-32e mode）** —— 在 IA-32e 模式下，处理器支持两种子模式：兼容模式（compatibility mode）和 64 位模式（64-bit mode）。64 位模式提供 64 位线性寻址，并支持大于 64 GB 的物理地址空间。兼容模式允许大多数传统的保护模式应用程序无需修改即可运行。

图 2-3 展示了处理器在各运行模式之间的切换过程。

![Figure 2-3. 处理器运行模式之间的切换](https://pic3.zhimg.com/80/v2-348d3c8ebb1c8117b92a85a7aedff23c_720w.webp)

处理器在上电或复位后会进入实地址模式。控制寄存器 CR0 中的 PE 标志位决定处理器处于实地址模式还是保护模式。详见第 11.9 节“模式切换”以及第 5.1.2 节“分页模式使能”。

EFLAGS 寄存器中的 VM 标志位用于决定处理器是在保护模式还是虚拟 8086 模式下运行。保护模式与虚拟 8086 模式之间的切换通常作为任务切换或从中断/异常处理程序返回的一部分来进行。详见第 22.2.5 节“进入虚拟 8086 模式”。

LMA 位（IA32\_EFER.LMA\[第 10 位]）决定处理器是否处于 IA-32e 模式。在 IA-32e 模式下，64 位或兼容子模式的运行由代码段的 CS.L 位决定。

处理器通过使能分页并设置 LME 位（IA32\_EFER.LME\[第 8 位]）可从保护模式进入 IA-32e 模式。详见第 11 章“处理器管理与初始化”。

当处理器在实地址模式、保护模式、虚拟 8086 模式或 IA-32e 模式下运行时，只要接收到 SMI，就会切换到系统管理模式（SMM）。执行 RSM 指令时，处理器总是返回到 SMI 发生时所在的模式。

### 2.2.1 扩展特性使能寄存器（Extended Feature Enable Register）

IA32\_EFER 型号专用寄存器（MSR）包含多个与 IA-32e 模式使能和操作相关的字段，同时还包含一个与页面访问权限修改相关的字段（详见第 5.6 节“访问权限”）。IA32\_EFER MSR 的结构如图 2-4 所示。

![Figure 2-4.  IA32\_EFER MSR（型号特定寄存器）布局](https://pic1.zhimg.com/80/v2-6d814d1cf1a0019aa6e1ecb16da2e224_720w.webp)

#### Table 2-1. IA32\_EFER 型号专用寄存器信息
| 位      | 描述                                                                                                   |
|---------|--------------------------------------------------------------------------------------------------------|
| 0       | SYSCALL 使能：IA32_EFER.SCE (读/写) <br> 在 64 位模式下使能 SYSCALL/SYSRET 指令。                       |
| 7:1     | 保留。                                                                                                |
| 8       | IA-32e 模式使能：IA32_EFER.LME (读/写) <br> 使能 IA-32e 模式操作。                                     |
| 9       | 保留。                                                                                                |
| 10      | IA-32e 模式激活：IA32_EFER.LMA (只读) <br> 置位时指示 IA-32e 模式已激活。                              |
| 11      | 执行禁用位使能：IA32_EFER.NXE (读/写) <br> 通过禁止从设置了 XD 位的 PAE 页进行指令获取来限制页面访问（详见第 5.6 节）。 |
| 63:12   | 保留。                                                                                                |

## 2.3 EFLAGS 寄存器中的系统标志与字段

EFLAGS 寄存器中的系统标志位与 IOPL 字段用于控制 I/O 操作、可屏蔽硬件中断、调试、任务切换以及虚拟 8086 模式（见图 2-5）。只有特权代码（通常是操作系统或管理程序代码）才应被允许修改这些位。

系统标志位与 IOPL 字段包括以下内容：

* **TF（Trap 标志，位 8）** —
  置位以启用单步调试模式；清零以禁用单步调试模式。在单步模式下，处理器在每条指令执行后生成一次调试异常（debug exception），从而允许在每条指令执行后检查程序的执行状态。如果应用程序通过 `POPF`、`POPFD` 或 `IRET` 指令设置 TF 标志，则在这些指令后的第一条指令执行后会触发调试异常。

![Figure 2-5. EFLAGS 寄存器中的系统标志位](https://pic4.zhimg.com/80/v2-d4da6df62f7186cd37284a35e77026b5_720w.webp)

* **IF（中断使能标志，位 9）**
  控制处理器对可屏蔽硬件中断请求的响应（参见第 7.3.2 节“可屏蔽硬件中断”）。该标志置位时处理器响应可屏蔽硬件中断；清零则禁止可屏蔽硬件中断。IF 标志不会影响异常或不可屏蔽中断（NMI）的产生。当前特权级（CPL）、I/O 特权级（IOPL）以及控制寄存器 CR4 中 VME 标志位的状态共同决定了 CLI、STI、POPF、POPFD 和 IRET 指令是否能修改 IF 标志。

* **IOPL（I/O 特权级字段，位 12 和 13）**
  指示当前运行程序或任务的 I/O 特权级（IOPL）。仅当当前程序或任务的 CPL 小于或等于 IOPL 时，才能访问 I/O 地址空间。POPF 和 IRET 指令只能在 CPL 为 0 时修改此字段。
  当虚拟模式扩展启用时（CR4.VME = 1），IOPL 也是控制虚拟 8086 模式下 IF 标志修改及中断处理的机制之一。详见《英特尔® 64 与 IA-32 架构软件开发手册》第1卷第 20 章“输入输出（Input/Output）”。

* **NT（嵌套任务标志，位 14）**
  控制中断和调用任务的链接（链式任务切换）。处理器在执行 CALL 指令、处理中断或异常导致任务调用时置位该标志，并在通过 IRET 指令从任务返回时检查并修改该标志。可通过 POPF/POPFD 指令显式设置或清除此标志。然而，修改此标志状态可能导致应用程序产生意外的异常。
  参见第 9.4 节“任务链接”。

* **RF（恢复标志，位 16）**
  控制处理器对指令断点条件的响应。当此标志置位时，会临时禁用由指令断点产生的调试异常（#DB），但其他异常条件仍然可能触发异常。当此标志清零时，指令断点会产生调试异常。
  RF 标志的主要功能是允许从指令断点导致的调试异常中恢复执行。调试软件必须在通过 IRETD 指令返回被中断程序前，在栈上 EFLAGS 镜像中设置此标志，以防止再次触发指令断点异常。处理器在成功执行返回的指令后自动清除 RF 标志，恢复断点异常功能。
  参见第 19.3.1.1 节“指令断点异常条件”。

* **VM（虚拟 8086 模式标志，位 17）**
  置位启用虚拟 8086 模式；清零返回保护模式。
  参见第 22.2.1 节“启用虚拟 8086 模式”。

* **AC（对齐检查或访问控制标志，位 18）**
  当 CR0 寄存器的 AM 位被设置时，用户模式数据访问的对齐检查功能由 AC 标志控制，仅当 AC=1 时启用对齐检查。若访问未对齐的操作数（例如奇地址的字或非4字节对齐地址的双字），将触发对齐检查异常。对齐检查异常仅在用户模式（CPL=3）下产生。默认属于特权级 0 的内存引用（如段描述符加载）即使由用户模式执行的指令引起，也不会触发此异常。
  对齐检查异常可用于数据对齐检查，特别是在与需要数据对齐的处理器交换数据时。同时，解释器也可通过故意让指针未对齐，以标记特定指针为特殊，从而避免逐个检查指针的开销，仅在使用特殊指针时才进行处理。
  若 CR4 寄存器中的 SMAP 位被置位，显式的特权模式数据访问用户模式页面仅在 AC 位设置为 1 时被允许。参见第 5.6 节“访问权限”。

* **VIF（虚拟中断标志，位 19）**
  保存 IF 标志的虚拟镜像。此标志与 VIP 标志结合使用。处理器仅在 CR4 寄存器中 VME 或 PVI 标志被设置且 IOPL 小于 3 时识别该标志。（VME 标志启用虚拟 8086 模式扩展；PVI 标志启用保护模式虚拟中断。）
  参见第 22.3.3.5 节“方法 6：软件中断处理”以及第 22.4 节“保护模式虚拟中断”。

* **VIP（虚拟中断挂起标志，位 20）**
  由软件设置以指示存在待处理的中断；清零表示无中断挂起。此标志与 VIF 标志结合使用。处理器仅在 CR4 寄存器的 VME 或 PVI 标志被设置且 IOPL 小于 3 时识别 VIP 标志。VME 标志启用虚拟 8086 模式扩展；PVI 标志启用保护模式虚拟中断。
  参见第 22.3.3.5 节“方法 6：软件中断处理”以及第 22.4 节“保护模式虚拟中断”。

* **ID（识别标志，位 21）**
  程序或过程能否设置或清除此标志表明是否支持 CPUID 指令。

---

### 2.3.1 IA-32e 模式下的系统标志与字段

在 64 位模式下，RFLAGS 寄存器扩展为 64 位，其中高 32 位保留。RFLAGS（64 位模式）或 EFLAGS（兼容模式）中的系统标志位参见图 2-5。

在 IA-32e 模式下，处理器不允许 VM 位被设置，因为不支持虚拟 8086 模式（任何设置 VM 位的尝试都会被忽略）。此外，处理器也不会主动设置 NT 位，但允许软件主动设置该位（注意，在 IA-32e 模式下，如果 NT 位被设置，执行 IRET 会触发通用保护异常）。

在 IA-32e 模式下，SYSCALL/SYSRET 指令可以通过编程方式指定哪些 RFLAGS/EFLAGS 中的位在执行指令时被清零。这些指令保存或恢复 EFLAGS/RFLAGS 的内容。

---

## 2.4 内存管理寄存器

处理器提供四个内存管理寄存器（GDTR、LDTR、IDTR 和 TR），它们用于指定控制分段内存管理的数据结构位置（参见图 2-6）。处理器还提供专用指令用于加载和存储这些寄存器的内容。

![Figure 2-6. 内存管理寄存器](https://pic3.zhimg.com/80/v2-48e81d08ddb9e7b5aa5dccc625296f4a_720w.webp)

### 2.4.1 全局描述符表寄存器（GDTR）

GDTR 寄存器保存 GDT 的基址（保护模式下为 32 位，IA-32e 模式下为 64 位）和 16 位表界限（table limit）。基址指定 GDT 第 0 字节的线性地址，表界限指定 GDT 的字节数。

LGDT 和 SGDT 指令分别用于加载和存储 GDTR 寄存器的内容。在处理器上电或复位时，基址被初始化为 0，界限被初始化为 0FFFFH。进入保护模式操作时，必须在处理器初始化流程中将新的基址加载到 GDTR 中。

详见第 3.5.1 节“段描述符表（Segment Descriptor Tables）”。

---

### 2.4.2 局部描述符表寄存器（LDTR）

LDTR 寄存器保存 LDT 的 16 位段选择子、基址（保护模式下为 32 位，IA-32e 模式下为 64 位）、段界限及描述符属性。基址指定 LDT 段第 0 字节的线性地址，段界限指定该段的字节数。详见第 3.5.1 节“段描述符表”。

LLDT 和 SLDT 指令分别用于加载和存储 LDTR 寄存器的段选择子部分。包含 LDT 的段必须在 GDT 中有一个段描述符。当 LLDT 指令将段选择子加载到 LDTR 时，LDT 描述符中的基址、界限和描述符属性也会自动加载到 LDTR 中。

任务切换时，LDTR 会自动加载为新任务对应 LDT 的段选择子和描述符。在向寄存器写入新的 LDT 信息前，LDTR 的内容不会被自动保存。

处理器上电或复位时，段选择子和基址被设置为默认值 0，界限被设置为 0FFFFH。

---

### 2.4.3 中断描述符表寄存器（IDTR）

IDTR 寄存器保存 IDT 的基址（保护模式下为 32 位，IA-32e 模式下为 64 位）和 16 位表界限。基址指定 IDT 第 0 字节的线性地址，表界限指定 IDT 的字节数。LIDT 和 SIDT 指令分别用于加载和存储 IDTR 寄存器的内容。处理器上电或复位时，基址被初始化为 0，界限被初始化为 0FFFFH。随后可在处理器初始化流程中修改寄存器中的基址和界限。

详见第 7.10 节“中断描述符表（IDT）”。

### 2.4.4 任务寄存器（TR）

任务寄存器（TR）保存当前任务的任务状态段（TSS）的16位段选择子、基址（保护模式下为32位，IA-32e模式下为64位）、段界限及描述符属性。段选择子指向GDT中的TSS描述符。基址指定TSS第0字节的线性地址，段界限指定TSS的字节数。详见第9.2.4节“任务寄存器”。

LTR和STR指令分别用于加载和存储任务寄存器中的段选择子。当LTR指令加载任务寄存器的段选择子时，TSS描述符中的基址、界限和描述符属性会自动加载到任务寄存器中。处理器上电或复位时，基址被设置为默认值0，界限设置为0FFFFH。

发生任务切换时，任务寄存器会自动加载新任务的TSS的段选择子和描述符。在向寄存器写入新的TSS信息之前，任务寄存器中的内容不会被自动保存。

---

## 2.5 控制寄存器（Control Registers）

控制寄存器（CR0、CR1、CR2、CR3和CR4；见图2-7）用于决定处理器的操作模式以及当前执行任务的特性。这些寄存器在所有32位模式以及兼容模式下均为32位宽。

在64位模式下，控制寄存器扩展至64位。MOV CRn指令用于操作控制寄存器的位，这些指令的操作数大小前缀会被忽略。此外：

* 控制寄存器可以通过MOV指令的控制寄存器读/写形式进行访问。在保护模式下，仅特权级0可以使用MOV指令读取或加载控制寄存器。这一限制意味着应用程序或运行于特权级1、2、3的操作系统程序无法读取或加载控制寄存器。

* CR0和CR4中某些位是保留位（reserved），必须写入0。尝试设置CR0\[31:0]的保留位将被忽略；尝试设置CR0\[63:32]中的保留位会触发通用保护异常（#GP(0)）；尝试设置CR4中的保留位也会触发通用保护异常（#GP(0)）。

* CR2寄存器的全部64位均可由软件写入。

* CR3寄存器中63\:MAXPHYADDR范围内的保留位必须为0，尝试设置这些位将引发通用保护异常（#GP(0)）。

* MOV CR2指令不会检查写入CR2的地址是否为规范地址（canonical）。

* 支持64位的处理器在退出IA-32e模式时，将保留控制寄存器的高32位。

* 在支持64位的处理器上，于非64位模式执行MOV指令到CR寄存器时，控制寄存器的高32位会被清零。

* CR8寄存器仅在64位模式下可用。

控制寄存器的概要如下所述，每个架构定义的控制字段在后续分别详细说明。在图2-7中，寄存器在64位模式下的位宽用括号表示（CR0除外）：

* **CR0** — 包含系统控制标志，用于控制处理器的操作模式与状态。
* **CR1** — 保留。
* **CR2** — 包含导致页故障的线性地址（page-fault linear address）。
* **CR3** — 包含分页结构层次的基地址的物理地址以及两个标志位（PCD和PWT）。基址仅指定物理地址的最高有效位（低12位默认为0）。因此，第一级分页结构必须按照页（4KB）对齐。PCD和PWT标志控制分页结构在处理器内部数据缓存中的缓存方式（不控制TLB缓存页目录信息的方式）。

* 在使用物理地址扩展（PAE, Physical Address Extension）时，CR3 寄存器包含页目录指针表（page-directory-pointer table）的基址。采用四级分页和五级分页时，CR3 寄存器分别包含 PML4 表（Page Map Level 4 table）和 PML5 表（Page Map Level 5 table）的基址物理地址。如果启用了 PCID（进程上下文标识符, Process-Context Identifier），CR3 的格式与图 2-7 所示不同。详见第 5.5 节“四级分页与五级分页”。

* 当支持线性地址掩码（Linear-Address Masking, LAM）时，CR3 包含两个用于控制用户指针掩码的位（详见第 4.4 节“线性地址掩码”）。

* 详见第 5 章“分页（Paging）”。

* **CR4** — 包含一组用于使能多种体系结构扩展的标志位，同时指示操作系统或管理程序对特定处理器功能的支持。CR4\[63:32] 位只能用于在进入 64 位模式后启用的 IA-32e 模式相关功能。CR4\[63:32] 位在 IA-32e 模式外无效。

* **CR8** — 提供对任务优先级寄存器（TPR, Task Priority Register）的读写访问。该寄存器指定操作系统用于控制允许中断处理器的外部中断优先级类别的优先级阈值。此寄存器仅在 64 位模式下可用。但在兼容模式下，中断过滤机制仍然有效。

![Figure 2-7. 控制寄存器](https://picx.zhimg.com/80/v2-b9c3dedcee496eeb257d09e9075b4125_720w.webp)

- Table 2-2 不同 EM、MP 和 TS 组合下 x87 FPU 指令的处理动作

| CR0 标志位 (EM, MP, TS) | x87 FPU 指令类型   | 动作说明                                 |
|-------------------------|--------------------|------------------------------------------|
|                         | 浮点指令           | WAIT/FWAIT 指令                          |
| 0 0 0                   | 执行               | 执行                                     |
| 0 0 1                   | #NM 异常           | 执行                                     |
| 0 1 0                   | 执行               | 执行                                     |
| 0 1 1                   | #NM 异常           | #NM 异常                                 |
| 1 0 0                   | #NM 异常           | 执行                                     |
| 1 0 1                   | #NM 异常           | 执行                                     |
| 1 1 0                   | #NM 异常           | 执行                                     |
| 1 1 1                   | #NM 异常           | #NM 异常                                 |


* CR0.EM（仿真，位 2）：

  * 置位时表示处理器没有内部或外部 x87 FPU；清零时表示存在 x87 FPU。
  * 此标志也影响 MMX/SSE/SSE2/SSE3/SSSE3/SSE4 指令的执行。
  * 置位 EM 时，执行任何 x87 FPU 指令会引发设备不可用异常（#NM）。若处理器没有内部 x87 FPU 或未连接外部数学协处理器，必须置位此标志，所有浮点指令都需通过软件仿真处理。
  * 当 EM 置位时，执行 MMX 指令会产生无效操作码异常（#UD）。支持 MMX 技术的处理器，EM 必须为 0 才能执行 MMX 指令。
  * 对于 SSE/SSE2/SSE3/SSSE3/SSE4，EM 置位时执行大部分相关指令也会引发 #UD 异常。仅当 EM 为 0 时，才能执行这些扩展。部分 SSE/SSE2/SSE3/SSSE3/SSE4 指令不受 EM 位影响，包括：PAUSE、PREFETCHh、SFENCE、LFENCE、MFENCE、MOVNTI、CLFLUSH、CRC32 和 POPCNT。

* CR0\.MP（监视协处理器，位 1）：

  * 控制 WAIT（或 FWAIT）指令与 TS 标志（位 3）之间的交互。
  * MP 置位且 TS 置位时，WAIT 指令会产生设备不可用异常（#NM）；MP 清零时，WAIT 指令忽略 TS 的设置。

* CR0\.PE（保护使能，位 0）：

  * 置位时启用保护模式，清零时启用实地址模式。
  * 该标志不会直接启用分页，仅使能段级保护。启用分页需同时设置 PE 和 PG 标志。

* CR3.PCD（页级缓存禁用，位 4）：

  * 控制访问当前分页结构层次第一级分页结构时使用的内存类型。
  * 若禁用分页、使用 PAE 分页或在四级/五级分页且 CR4.PCIDE=1 时，该位无效。

* CR3.PWT（页级直写，位 3）：

  * 控制访问当前分页结构层次第一级分页结构时使用的内存类型。
  * 若禁用分页、使用 PAE 分页或在四级/五级分页且 CR4.PCIDE=1 时，该位无效。

* CR3.LAM\_U57（用户 LAM57 使能，位 61）：

  * 置位时，启用用户指针的 LAM57（掩码线性地址的 62:57 位），并覆盖 CR3.LAM\_U48。

* CR3.LAM\_U48（用户 LAM48 使能，位 62）：

  * 置位且 CR3.LAM\_U57 为 0 时，启用用户指针的 LAM48（掩码线性地址的 62:48 位）。

* CR4.VME（虚拟 8086 模式扩展，位 0）：

  * 置位时在虚拟 8086 模式下启用中断与异常处理扩展，清零时禁用扩展。
  * 启用虚拟模式扩展能提升虚拟 8086 应用性能，并提供 VIF（虚拟中断标志）硬件支持，提升多任务和多处理器环境下的 8086 程序可靠性。

* CR4.PVI（保护模式虚拟中断，位 1）：

  * 置位时在保护模式下启用 VIF（虚拟中断标志）硬件支持，清零时在保护模式下禁用 VIF 标志。

* CR4.TSD（时间戳禁止，位 2）：

  * 置位时，RDTSC 指令仅能在特权级 0 下执行；清零时任何特权级都可执行 RDTSC。
  * 若支持（CPUID.80000001H\:EDX=1），该位对 RDTSCP 指令同样适用。

* CR4\.DE（调试扩展，位 3）：

  * 置位时，引用调试寄存器 DR4 和 DR5 会引发无效操作码（#UD）异常；清零时，处理器会将对 DR4 和 DR5 的访问别名处理，以兼容早期 IA-32 处理器。

* CR4.PSE（页大小扩展，位 4）：

  * 置位时，32 位分页下支持 4 MB 页面；清零时，32 位分页仅支持 4 KB 页面。

* CR4.PAE（物理地址扩展，位 5）：

  * 置位时，使分页生成大于 32 位的物理地址；清零时，物理地址限制为 32 位。进入 IA-32e 模式前必须置位 PAE。

* CR4.MCE（机器检查使能，位 6）：

  * 置位时使能机器检查异常，清零时禁用机器检查异常。

* CR4.PGE（全局页使能，位 7）：

  * 置位时启用全局页功能，清零时禁用。全局页允许常用或共享页面对所有用户均为全局（通过页目录指针表、页目录或页表项的全局标志位 bit 8 实现）。全局页在任务切换或写 CR3 时不会被从 TLB 刷新。
  * 启用全局页前，必须先启用分页（设置 CR0\.PG）。反向顺序可能影响程序正确性及处理器性能。

* CR4.PCE（性能监控计数器使能，位 8）

  * 置位时，允许所有特权级别的程序或过程执行 RDPMC 指令；清零时，仅允许特权级 0 执行 RDPMC 指令。

* CR4.OSFXSR（操作系统对 FXSAVE 和 FXRSTOR 指令的支持，位 9）

  * 置位时，该标志：

    1. 向软件表明操作系统支持 FXSAVE 和 FXRSTOR 指令；
    2. 使 FXSAVE 和 FXRSTOR 指令能够在保存/恢复 x87 FPU 和 MMX 寄存器的同时，保存/恢复 XMM 和 MXCSR 寄存器的内容；
    3. 允许处理器执行 SSE/SSE2/SSE3/SSSE3/SSE4 指令（除 PAUSE、PREFETCHh、SFENCE、LFENCE、MFENCE、MOVNTI、CLFLUSH、CRC32 和 POPCNT 以外）。
  * 如果该标志未置位，FXSAVE 和 FXRSTOR 只保存/恢复 x87 FPU 和 MMX 寄存器内容，不保证保存/恢复 XMM 和 MXCSR 寄存器内容。处理器在尝试执行任何 SSE/SSE2/SSE3/SSSE3/SSE4 指令（上述例外除外）时会引发无效操作码异常（#UD）。
  * 操作系统或管理程序必须显式设置此标志。

::: info 注意
CPUID 功能位 FXSR 表示 FXSAVE/FXRSTOR 指令可用。OSFXSR 位为操作系统提供了启用 FXSAVE/FXRSTOR 保存/恢复 X87 FPU、XMM 和 MXCSR 寄存器内容的方法。因此，OSFXSR 位也表明操作系统提供了对 SSE/SSE2/SSE3/SSSE3/SSE4 的上下文切换支持。
:::

* CR4.OSXMMEXCPT（操作系统对非屏蔽 SIMD 浮点异常支持，位 10）：

  * 置位时，表示操作系统支持通过异常处理程序处理非屏蔽 SIMD 浮点异常（#XM）。此异常仅由 SSE/SSE2/SSE3/SSE4.1 SIMD 浮点指令生成。
  * 操作系统或管理程序必须显式设置此标志。如果未设置该标志，处理器在检测到非屏蔽 SIMD 浮点异常时会产生无效操作码异常（#UD）。

* CR4.UMIP（用户模式指令防护，位 11）：

  * 置位时，当 CPL > 0 时禁止执行以下指令：SGDT、SIDT、SLDT、SMSW 和 STR。尝试执行将引发通用保护异常（#GP）。

* CR4.LA57（57 位线性地址，位 12）：

  * 在 IA-32e 模式下置位时，处理器采用五级分页转换 57 位线性地址；清零时，采用四级分页转换 48 位线性地址。此位在 IA-32e 模式下不可修改。
  * 详见第 5 章“分页（Paging）”。

* CR4.VMXE（VMX 使能，位 13）：

  * 置位时启用 VMX 操作。详见第 25 章“虚拟机扩展简介（Introduction to Virtual Machine Extensions）”。

* CR4.SMXE（SMX 使能，位 14）：

  * 置位时启用 SMX 操作。详见《Intel® 64 与 IA-32 架构软件开发手册》第 2D 卷第 7 章“更安全模式扩展参考（Safer Mode Extensions Reference）”。

* CR4.FSGSBASE（FSGSBASE 使能，位 16）：

  * 置位时，启用 RDFSBASE、RDGSBASE、WRFSBASE 和 WRGSBASE 指令。

* CR4.PCIDE（PCID 使能，位 17）：

  * 置位时启用进程上下文标识符（PCID）。仅在 IA-32e 模式（IA32\_EFER.LMA = 1）下有效。详见第 5.10.1 节“进程上下文标识符（Process-Context Identifiers, PCIDs）”。

* CR4.OSXSAVE（XSAVE 与处理器扩展状态使能，位 18）：

  * 置位时，该标志：（1）通过 CPUID.01H\:ECX.OSXSAVE\[27] 指示操作系统支持一般软件使用 XGETBV、XSAVE 和 XRSTOR 指令；（2）允许 XSAVE 和 XRSTOR 指令保存/恢复 x87 FPU 状态（包括 MMX 寄存器）、SSE 状态（XMM 寄存器和 MXCSR），以及 XCR0 启用的其他处理器扩展状态；（3）允许处理器执行 XGETBV 和 XSETBV 指令以读写 XCR0。
  * 详见第 2.6 节和第 15 章“指令集扩展与处理器扩展状态的系统编程”。

* CR4.KL（Key-Locker 使能位，位 19）：

  * 置位时，启用 LOADIWKEY 指令；此外，如果系统固件已激活 AES Key Locker 指令，CPUID.19H\:EBX.AESKLE\[0] 枚举为 1，AES Key Locker 指令可用。[^1]
  * 清零时，CPUID.19H\:EBX.AESKLE\[0] 枚举为 0，执行任何 Key Locker 指令都会产生无效操作码异常（#UD）。

* CR4.SMEP（SMEP 使能位，位 20）：

  * 置位时，启用特权级执行防护（Supervisor-mode Execution Prevention, SMEP）。详见第 5.6 节“访问权限（Access Rights）”。

* CR4.SMAP（SMAP 使能位，位 21）：

  * 置位时，启用特权级访问防护（Supervisor-mode Access Prevention, SMAP）。详见第 5.6 节“访问权限（Access Rights）”。

* CR4.PKE（用户模式页面保护键使能，位 22）：

  * 置位时，四级分页和五级分页会将每个用户模式线性地址与一个保护键关联。此标志置位时（通过 CPUID.(EAX=07H, ECX=0H)\:ECX.OSPKE \[bit 4] 表示），表明操作系统支持使用 PKRU 寄存器来指定每个保护键下用户模式线性地址的读写权限。
  * 此位同时允许通过 RDPKRU 和 WRPKRU 指令访问 PKRU 寄存器。

* CR4.CET（控制流强制技术，位 23）：

  * 置位时启用控制流强制技术（Control-flow Enforcement Technology, CET）。详见《IA-32 Intel® 架构软件开发手册》第 1 卷第 18 章“控制流强制技术（CET）”。
  * 仅当 CR0.WP 已设置时才可置位本标志，且要清除 CR0.WP，必须先清除本标志。

* CR4.PKS（特权模式页面保护键使能，位 24）：

  * 置位时，四级分页和五级分页会将每个特权模式线性地址与一个保护键关联。此标志允许通过 IA32\_PKRS MSR 为每个保护键指定特权模式线性地址的读写权限。

* CR4.UINTR（用户中断使能，位 25）：

  * 置位时，启用用户中断，包括用户中断投递、通知识别以及用户中断相关指令。

* CR4.LAM\_SUP（特权 LAM 使能，位 28）：

  * 置位时，启用特权指针的 LAM（线性地址掩码, Linear-Address Masking）。详见第 4.4 节“线性地址掩码”。

* CR8.TPL（任务优先级级别，CR8 的位 3:0）：

  * 设置要屏蔽的最高优先级中断的阈值。值为 0 表示允许所有中断；值为 15 表示屏蔽所有中断。此字段仅在 64 位模式下有效。

### 2.5.1 控制寄存器标志的 CPUID 适配性

并非所有处理器都实现了控制寄存器 CR4 中的所有标志位。除 PCE 标志外，其余标志均可通过 CPUID 指令进行适配性查询，在实际使用前可确定这些标志是否被处理器实现。

对于支持 Intel 64 架构的处理器，CR8 寄存器可用。

---

## 2.6 扩展控制寄存器（包括 XCR0）

如果 CPUID.01H\:ECX.XSAVE（位 26）为 1，则表示处理器支持一个或多个扩展控制寄存器（XCR, Extended Control Registers）。目前唯一定义的此类寄存器是 XCR0。XCR0 指定了操作系统需要进行上下文管理的一组处理器状态组件，例如 x87 FPU 状态、SSE 状态、AVX 状态等。操作系统需要对 XCR0 进行编程，以反映其所支持并提供上下文管理的特性。

![Figure 2-8. XCR0](https://pic4.zhimg.com/80/v2-557aa55efb73b6176a446c8ea30805ef_720w.webp)

软件仅当 CR4.OSXSAVE（位 18）为 1 时才可以访问 XCR0（此位也可通过 CPUID.01H\:ECX.OSXSAVE\[27] 读取）。软件可使用 CPUID 叶函数 0DH 枚举处理器支持的 XCR0 位（详见《Intel® 64 与 IA-32 架构软件开发手册》第 2A 卷中的 CPUID 指令）。XCR0 中的每一位代表一个受支持的状态组件。系统软件通过 XSETBV 指令向 XCR0 加载适当的位掩码值，从而使能相应的状态组件。

由于 XCR0（除位 63 外）的每一位对应一个处理器状态组件，XCR0 最多可支持 63 组处理器状态组件。XCR0 的第 63 位为将来扩展保留，不代表任何处理器状态组件。

当前，XCR0 定义对以下状态组件的支持：

* **XCR0.X87（位 0）**：该位必须为 1。若尝试将该位写为 0，则会引发 #GP 异常。
* **XCR0.SSE（位 1）**：若为 1，XSAVE 特性集可用于管理 MXCSR 和 XMM 寄存器（64 位模式下为 XMM0-XMM15，否则为 XMM0-XMM7）。
* **XCR0.AVX（位 2）**：若为 1，可执行 Intel AVX 指令，并可用 XSAVE 特性集管理 YMM 寄存器的高 128 位（64 位模式下为 YMM0-YMM15，否则为 YMM0-YMM7）。
* **XCR0.BNDREG（位 3）**：若为 1，可执行 Intel MPX 指令，并可用 XSAVE 特性集管理边界寄存器 BND0–BND3。
* **XCR0.BNDCSR（位 4）**：若为 1，可执行 Intel MPX 指令，并可用 XSAVE 特性集管理 BNDCFGU 和 BNDSTATUS 寄存器。
* **XCR0.opmask（位 5）**：若为 1，可执行 Intel AVX-512 指令，并可用 XSAVE 特性集管理 opmask 寄存器 k0–k7。
* **XCR0.ZMM\_Hi256（位 6）**：若为 1，可执行 Intel AVX-512 指令，并可用 XSAVE 特性集管理较低 ZMM 寄存器（ZMM0-ZMM15，64 位模式；否则 ZMM0-ZMM7）的高 256 位。
* **XCR0.Hi16\_ZMM（位 7）**：若为 1，可执行 Intel AVX-512 指令，并可用 XSAVE 特性集管理高位 ZMM 寄存器（仅 64 位模式下的 ZMM16-ZMM31）。
* **XCR0.PKRU（位 9）**：若为 1，XSAVE 特性集可用于管理 PKRU 寄存器（详见第 2.7 节）。
* **XCR0.TILECFG（位 17）**：若为 1，并且 XCR0.TILEDATA 也为 1，则可执行 Intel AMX 指令，并可用 XSAVE 特性集管理 TILECFG。
* **XCR0.TILEDATA（位 18）**：若为 1，且 XCR0.TILECFG 也为 1，则可执行 Intel AMX 指令，并可用 XSAVE 特性集管理 TILEDATA。

使用 XSETBV 指令写入 XCR0 时，如果发生以下任一情况，将导致通用保护异常（#GP）：

* 设置了处理器指定为 XCR0 保留位的某一位（可通过 EAX=0DH, ECX=0H 的 CPUID 指令后 EAX 和 EDX 内容判定）。
* 清除 XCR0.x87。
* 清除 XCR0.SSE 且设置 XCR0.AVX。
* 清除 XCR0.AVX 且设置 XCR0.opmask、XCR0.ZMM\_Hi256 或 XCR0.Hi16\_ZMM 中任一位。
* 仅设置 XCR0.BNDREG 或 XCR0.BNDCSR，而未同时设置二者。
* 仅设置 XCR0.opmask、XCR0.ZMM\_Hi256、XCR0.Hi16\_ZMM 中的部分位，而非三者全都设置。
* 仅设置 XCR0.TILECFG 或 XCR0.TILEDATA，而未同时设置二者。

处理器复位后，XCR0 除第 0 位外，其余各位均被清零；XCR0\[0] 被设置为 1。

---

## 2.7 保护键权限寄存器（PKRU 和 IA32\_PKRS）

处理器可能支持两个保护键权限寄存器之一或两者：用于用户模式页面的 PKRU，和用于特权模式页面的 IA32\_PKRS MSR（MSR 索引 6E1H）。四级分页和五级分页会为每个页面关联一个 4 位的保护键。保护键权限寄存器根据页面的保护键决定访问权限。

* 若 CPUID.(EAX=07H, ECX=0H)\:ECX.PKU \[位 3] = 1，则处理器支持用户模式页面的保护键特性。当 CR4.PKE = 1 时，软件可以使用用户页面的保护键权限寄存器（PKRU）为每个保护键指定用户模式页面的访问权限。
* 若 CPUID.(EAX=07H, ECX=0H)\:ECX.PKS \[位 31] = 1，则处理器支持特权模式页面的保护键特性。当 CR4.PKS = 1 时，软件可以使用特权页面的保护键权限寄存器（IA32\_PKRS MSR）为每个保护键指定特权模式页面的访问权限。

![Figure 2-9. 保护键权限寄存器的格式](https://pic1.zhimg.com/80/v2-c84eed6e970e887c755deefe5a339996_720w.webp)

每个保护键权限寄存器的格式如图 2-9 所示。每个寄存器包含 16 对禁用控制位，用于根据其保护键防止对线性地址（用户模式或特权模式，取决于寄存器类型）的数据访问。每个保护键 i（0 ≤ i ≤ 15）在每个保护键权限寄存器中关联两个位：

* 第 2i 位，表示为 “ADi”（访问禁用，Access Disable）：如果置位，处理器将阻止对具有保护键 i 的线性地址（用户模式或特权模式，取决于寄存器类型）的任何数据访问。
* 第 2i+1 位，表示为 “WDi”（写入禁用，Write Disable）：如果置位，处理器将阻止对具有保护键 i 的线性地址（用户模式或特权模式，取决于寄存器类型）的写入访问。

（IA32\_PKRS MSR 的位 63:32 为保留位，必须为零。）

关于处理器如何使用保护键权限寄存器控制对线性地址的访问，详见第 5.6.2 节“保护键（Protection Keys）”。

软件可通过 RDPKRU 和 WRPKRU 指令读写 PKRU。可使用 RDMSR 和 WRMSR 指令读写 IA32\_PKRS MSR。通过 WRMSR 写入 IA32\_PKRS MSR 时，写操作不是串行化（non-serializing）的。

## 2.8 系统指令概要

系统指令（System Instructions）用于处理系统级功能，如加载系统寄存器、缓存管理、中断管理或调试寄存器配置。其中许多指令仅能由操作系统或管理程序（即运行在特权级 0 的过程）执行。部分指令可以在任意特权级执行，因此对应用程序也可用。

表 2-3 列出了系统指令，并指明了这些指令是否对应用程序可用及有用。这些指令的详细说明见《Intel® 64 与 IA-32 架构软件开发手册》第 2A、2B、2C 和 2D 卷。

- Table 2-3

| 指令           | 描述                                             | 对应用程序有用？ | 是否对应用程序受保护？     |
| -------------- | ------------------------------------------------ | ---------------- | -------------------------- |
| LLDT           | 加载 LDT 寄存器                                  | 否               | 是                         |
| SLDT           | 存储 LDT 寄存器                                  | 否               | 若 CR4.UMIP = 1，则是      |
| LGDT           | 加载 GDT 寄存器                                  | 否               | 是                         |
| SGDT           | 存储 GDT 寄存器                                  | 否               | 若 CR4.UMIP = 1，则是      |
| LTR            | 加载任务寄存器（Task Register）                   | 否               | 是                         |
| STR            | 存储任务寄存器                                   | 否               | 若 CR4.UMIP = 1，则是      |
| LIDT           | 加载 IDT 寄存器                                  | 否               | 是                         |
| SIDT           | 存储 IDT 寄存器                                  | 否               | 若 CR4.UMIP = 1，则是      |
| MOV CRn        | 读写控制寄存器                                   | 否               | 是                         |
| SMSW           | 存储 MSW                                         | 是¹              | 若 CR4.UMIP = 1，则是      |
| LMSW           | 加载 MSW                                         | 否               | 是                         |
| CLTS           | 清除 CR0 中的 TS 标志                            | 否               | 是                         |
| ARPL           | 调整 RPL                                         | 是¹ ⁵           | 否                         |
| LAR            | 加载访问权限                                     | 是               | 否                         |
| LSL            | 加载段界限                                       | 是               | 否                         |
| VERR           | 验证是否可读                                     | 是               | 否                         |
| VERW           | 验证是否可写                                     | 是               | 否                         |
| MOV DRn        | 读写调试寄存器                                   | 否               | 是                         |
| INVD           | 使缓存失效（不回写）                             | 否               | 是                         |
| WBINVD         | 使缓存失效（带回写）                             | 否               | 是                         |
| INVLPG         | 使 TLB 条目失效                                  | 否               | 是                         |
| HLT            | 停止处理器                                       | 否               | 是                         |
| LOCK（前缀）   | 总线锁定                                         | 是               | 否                         |
| RSM            | 从系统管理模式返回                               | 否               | 是                         |
| RDMSR³         | 读取特定型号寄存器（MSR）                        | 否               | 是                         |
| WRMSR³         | 写入特定型号寄存器（MSR）                        | 否               | 是                         |
| RDPMC⁴         | 读取性能监控计数器                               | 是               | 是²                        |
| RDTSC³         | 读取时间戳计数器                                 | 是               | 是²                        |
| RDTSCP⁷        | 读取序列化时间戳计数器                           | 是               | 是²                        |
| XGETBV         | 返回 XCR0 的状态                                 | 是               | 否                         |
| XSETBV         | 使能一个或多个处理器扩展状态                     | 否               | 是                         |

::: tip 注释
1. 仅对在 CPL（特权级）为 1 或 2 的应用程序有用。
2. 控制寄存器 CR4 中的 TSD 和 PCE 标志控制 CPL 为 3 的应用程序对这些指令的访问权限。
3. 这些指令自 Pentium 处理器起被引入 IA-32 架构。
4. 该指令自 Pentium Pro 处理器和带有 MMX 技术的 Pentium 处理器起被引入 IA-32 架构。
5. 该指令在 64 位模式下不被支持。
6. 应用程序可用 XGETBV 查询哪些处理器扩展状态已启用。
7. RDTSCP 指令自 Intel Core i7 处理器引入。
:::

### 2.8.1 加载和存储系统寄存器

GDTR、LDTR、IDTR 和 TR 寄存器各自配有加载和存储指令，用于将数据加载到寄存器或从寄存器存储数据：

* **LGDT（加载 GDTR 寄存器）**：从内存加载 GDT 基地址和界限到 GDTR 寄存器。
* **SGDT（存储 GDTR 寄存器）**：将 GDTR 寄存器中的 GDT 基地址和界限存储到内存。
* **LLDT（加载 LDTR 寄存器）**：从内存加载 LDT 段选择子和段描述符到 LDTR 寄存器。（段选择子操作数也可以位于通用寄存器中。）
* **SLDT（存储 LDTR 寄存器）**：将 LDTR 寄存器中的 LDT 段选择子存储到内存或通用寄存器。
* **LTR（加载任务寄存器）**：从内存加载任务状态段（TSS）的段选择子和段描述符到任务寄存器。（段选择子操作数也可以位于通用寄存器中。）
* **STR（存储任务寄存器）**：将任务寄存器中当前任务 TSS 的段选择子存储到内存或通用寄存器。
* **LIDT（加载 IDTR 寄存器）**：从内存加载 IDT 基地址和界限到 IDTR 寄存器。
* **SIDT（存储 IDTR 寄存器）**：将 IDTR 寄存器中的 IDT 基地址和界限存储到内存。

LMSW（加载机器状态字）和 SMSW（存储机器状态字）指令操作控制寄存器 CR0 的第 0 到 15 位。这两条指令为与 16 位 Intel 286 处理器兼容而设计。为 32 位 IA-32 处理器编写的程序不应使用这两条指令，应改用 MOV CR 指令访问 CR0。

CLTS（清除 CR0 中的 TS 标志）指令用于处理设备不可用异常（#NM），即处理器在 TS 标志已设置时尝试执行浮点指令所发生的异常。该指令允许在 x87 FPU 上下文保存后清除 TS 标志，从而避免后续出现 #NM 异常。更多关于 TS 标志的信息，参见 2.5 节“控制寄存器”。

控制寄存器（CR0、CR1、CR2、CR3、CR4 和 CR8）通过 MOV 指令加载。该指令可以将通用寄存器的内容加载到控制寄存器，或将控制寄存器的内容存储到通用寄存器。

### 2.8.2 访问权限的验证

处理器提供了多条指令，用于检查段选择子和段描述符，以确定对其相关段的访问是否被允许。这些指令复现了处理器自动完成的部分访问权限和类型检查，使操作系统或管理程序能够预防由访问异常引发的异常中断。

* **ARPL（调整 RPL）指令**：用于调整段选择子的 RPL（请求者特权级）以匹配提供该段选择子的程序或过程的特权级。关于该指令的功能与使用，详见 6.10.4 节“调用者访问权限检查（ARPL 指令）”。注意：ARPL 在 64 位模式下不受支持。
* **LAR（加载访问权限）指令**：用于验证指定段的可访问性，并将段描述符中的访问权限信息加载到通用寄存器中。软件可通过检查访问权限，判断段类型是否与其预期用途兼容。详见 6.10.1 节“访问权限检查（LAR 指令）”。
* **LSL（加载段界限）指令**：用于验证指定段的可访问性，并将段描述符中的段界限加载到通用寄存器中。软件可将段界限与段内的偏移量进行比较，判断偏移量是否位于段的有效范围内。详见 6.10.3 节“指针偏移量界限检查（LSL 指令）”。
* **VERR（读取权限验证）和 VERW（写入权限验证）指令**：分别用于验证选定段在给定 CPL 下是否可读或可写。详见 6.10.2 节“读/写权限检查（VERR 与 VERW 指令）”。

### 2.8.3 加载和存储调试寄存器

处理器内部的调试功能由一组 8 个调试寄存器（DR0–DR7）进行控制。可使用 MOV 指令向这些寄存器加载或存储配置信息。

对于支持 Intel 64 架构的处理器，调试寄存器 DR0–DR7 均为 64 位。在 32 位模式和兼容模式下，对调试寄存器的写操作会将高 32 位填充为零，读取操作则返回低 32 位。在 64 位模式下，DR6 和 DR7 的高 32 位为保留位，必须写为零。如将这些高位中的任意一位写为 1，将引发异常 #GP(0)。

在 64 位模式下，MOV DRn 指令可读写调试寄存器的全部 64 位（操作数大小前缀会被忽略）。DR0–DR3 的全部 64 位均可由软件写入。不过，MOV DRn 指令不会检查写入 DR0–DR3 的地址是否在实现范围之内。仅对处理器实现所支持的有效地址进行地址匹配。

### 2.8.4 失效缓存和 TLB

处理器提供了多条指令，用于显式失效（invalidate）其缓存和 TLB 条目：

* **INVD（失效缓存且不写回）**：该指令使处理器内部所有数据和指令缓存条目失效，并向外部缓存发出信号，指示其也应失效。不会将修改过的缓存行写回内存。
* **WBINVD（失效缓存并写回）**：该指令与 INVD 功能类似，但会在使缓存失效之前，将内部缓存中已修改的行写回主存。WBINVD 在使当前执行逻辑处理器或处理器核心本地缓存失效后，会向缓存层级结构中更高层次的共享缓存发出信号，使其将执行指令时处于已修改状态的数据写回，并将其内容失效。

注意，非共享缓存可能不会被写回或失效。例如，下图（图 2-10）中，如果在 LP0 或 LP1 上执行 WBINVD，则 LP0/LP1 共享的 L1 和 L2 缓存以及共享的 L3 缓存会被写回并失效；但未与 LP0 和 LP1 共享的 L1 和 L2 缓存则不会被写回或失效。

![Figure 2-10. WBINVD 对共享与非共享缓存层级的失效](https://pic1.zhimg.com/80/v2-992a8ba80870e31530031878b63f53dc_720w.webp)

INVLPG（失效 TLB 条目） 指令用于失效（刷新）指定页面的 TLB 条目。

### 2.8.5 控制处理器

* **HLT（暂停处理器）** 指令会使处理器停止运行，直到收到已使能的中断（如 NMI 或 SMI，通常默认启用）、调试异常、BINIT# 信号、INIT# 信号或 RESET# 信号。处理器在进入暂停模式时，会产生特殊的总线周期以指示这一状态。

  * 硬件对该信号的响应方式多种多样。例如，前面板的指示灯可能被点亮；也可能生成用于记录诊断信息的 NMI 中断；还可能触发复位初始化（BINIT# 引脚是从 Pentium Pro 处理器开始引入的）。如果在关机期间有未处理的非唤醒事件（如 A20M# 中断）挂起，它们会在关机唤醒事件处理完成后被处理。

* **LOCK（前缀）**：在修改内存操作数时，LOCK 前缀会强制执行锁定（原子性）的读-改-写操作。该机制用于多处理器系统中处理器间的可靠通信，具体如下：

  * 对于 Pentium 及更早的 IA-32 处理器，LOCK 前缀会在指令执行期间拉高 LOCK# 信号，从而始终产生显式总线锁定。
  * 对于 Pentium 4、Intel Xeon 及 P6 系列处理器，锁定操作可通过缓存锁定或总线锁定实现。如果内存访问可缓存且只影响单个缓存行，则采用缓存锁定，操作期间系统总线和实际内存不会被锁定；此时，系统总线上的其他同类处理器会按需写回已修改数据并失效其缓存，以保证系统内存一致性。如果内存访问不可缓存和/或跨越缓存行边界，则会拉高 LOCK# 信号，处理器在锁定期间不会响应总线控制请求。

* **RSM（从系统管理模式返回）**：该指令将处理器（从上下文转储）恢复到进入系统管理模式（SMM）中断前的状态。

### 2.8.6 读取性能监控计数器和时间戳计数器

* **RDPMC（读取性能监控计数器）** 和 **RDTSC（读取时间戳计数器）** 指令分别允许应用程序读取处理器的性能监控计数器和时间戳计数器。

  * 基于 Intel NetBurst® 微架构的处理器配备有十八个 40 位性能监控计数器；P6 系列处理器有两个 40 位计数器。
  * Intel Atom® 处理器和大多数基于 Intel Core 微架构的处理器支持两种类型的性能监控计数器：一种为可编程性能计数器（类似于 P6 系列），另一种为三组固定功能性能监控计数器。每代处理器的可编程和固定功能性能监控计数器的详细说明，参见第 20 章“最后分支记录”。
  * 可编程性能监控计数器既可用于统计事件发生的次数，也可用于统计事件的持续时间。可用于可编程计数器监控的事件一般为型号相关（除了由 CPUID 叶 0AH 枚举的架构性能事件）；这些事件可能包括解码指令数、接收中断数或缓存加载次数等。各个计数器可以分别设置以监控不同事件。

* 使用系统指令 **WRMSR** 设置相关寄存器的值：

  * 对于 IA32\_PERFEVTSELx MSR、45 个 ESCRs 以及 18 个 CCCR MSR（适用于 Pentium 4 和 Intel Xeon 处理器）。
  * 对于 PerfEvtSel0 或 PerfEvtSel1 MSR（适用于 P6 系列处理器）。

* **RDPMC** 指令将所选计数器的当前计数值加载到 EDX\:EAX 寄存器中。

固定功能性能计数器仅记录在 [https://perfmon-events.intel.com/](https://perfmon-events.intel.com/) 上定义的特定事件，其宽度和数量可通过 CPUID 叶 0AH 枚举获得。

时间戳计数器（time-stamp counter, TSC）是特定于处理器型号的 64 位计数器，在每次处理器复位时被重置为零。如果不重置，当处理器以 3GHz 时钟频率运行时，该计数器每年约会递增 9.5 x 10<sup>16</sup> 次。在该频率下，计数器溢出（回绕）需要超过 190 年。**RDTSC** 指令会将时间戳计数器的当前值加载到 EDX\:EAX 寄存器中。

更多关于性能监控和时间戳计数器的信息，详见第 21.1 节“性能监控概述”和第 19.17 节“时间戳计数器”。

RDTSC 指令自 Pentium 处理器起引入 IA-32 架构。RDPMC 指令自 Pentium Pro 处理器以及带有 MMX 技术的 Pentium 处理器起引入 IA-32 架构。早期的 Pentium 处理器虽然具有两个性能监控计数器，但只能通过 RDMSR 指令在特权级 0 读取。

#### 2.8.6.1 在 64 位模式下读取计数器

在 64 位模式下，**RDTSC** 的操作方式与保护模式下相同。时间戳计数器（TSC）的计数值存储在 EDX\:EAX（或 RDX\[31:0]\:RAX，高 32 位 RDX\[63:32]\:RAX 被清零）。

**RDPMC** 需要使用索引来指定性能监控计数器的偏移量。在 Pentium 4 或 Intel Xeon 处理器系列的 64 位模式下，该索引由 ECX\[30:0] 指定。所选性能监控计数器的当前值存储在 EDX\:EAX（或 RDX\[31:0]\:RAX，高 32 位清零）。

---

### 2.8.7 读取和写入特定于型号的寄存器（MSRs）

**RDMSR（读取型号特定寄存器）** 和 **WRMSR（写入型号特定寄存器）** 指令分别允许读取和写入处理器的 64 位型号特定寄存器（Model-Specific Registers, MSRs）。要读取或写入的 MSR 由 ECX 寄存器的值指定。

* **RDMSR**：将指定 MSR 的值读入 EDX\:EAX 寄存器。
* **WRMSR**：将 EDX\:EAX 寄存器中的值写入指定的 MSR。

RDMSR 和 WRMSR 指令自 Pentium 处理器开始引入 IA-32 架构。更多信息参见 11.4 节“型号特定寄存器（MSRs）”。

#### 2.8.7.1 64 位模式下的 MSR 读写

在 64 位模式下，RDMSR 和 WRMSR 需要使用索引指定 MSR 地址。该索引为 32 位，通过 ECX 指定。

### 2.8.8 启用处理器扩展状态

**XSETBV** 指令用于在 XCR0 中启用操作系统对各个处理器扩展状态的支持（详见第 2.6 节）。


[^1]: 软件可以在设置 CR4.KL 后检查 CPUID.19H\:EBX.AESKLE\[0] 以判断 AES Key Locker 指令是否已启用。部分处理器可在未由系统固件激活的情况下启用此类指令。某些处理器在系统管理模式（SMM）下不支持使用 AES Key Locker 指令，这些处理器无论 CR4.KL 设置如何，CPUID.19H\:EBX.AESKLE\[0] 在 SMM 下均为 0。

